// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: rpc/leader.proto
#ifndef GRPC_rpc_2fleader_2eproto__INCLUDED
#define GRPC_rpc_2fleader_2eproto__INCLUDED

#include "rpc/leader.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
    class CompletionQueue;
    class ServerCompletionQueue;
    class ServerContext;
} // namespace grpc_impl

namespace grpc {
    namespace experimental {
        template <typename RequestT, typename ResponseT> class MessageAllocator;
    } // namespace experimental
} // namespace grpc

namespace cluster {
    namespace rpc {

        // Cluster management service: using Raft Leader Election algorithm
        class ManagementService final {
        public:
            static constexpr char const *service_full_name() {
                return "cluster.rpc.ManagementService";
            }
            class StubInterface {
            public:
                virtual ~StubInterface() {}
                virtual ::grpc::Status
                GetNetworkState(::grpc::ClientContext *context,
                                const ::cluster::rpc::NetworkStateRequest &request,
                                ::cluster::rpc::NetworkStateResponse *response) = 0;
                std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                    ::cluster::rpc::NetworkStateResponse>>
                AsyncGetNetworkState(::grpc::ClientContext *context,
                                     const ::cluster::rpc::NetworkStateRequest &request,
                                     ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                        ::cluster::rpc::NetworkStateResponse>>(
                        AsyncGetNetworkStateRaw(context, request, cq));
                }
                std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                    ::cluster::rpc::NetworkStateResponse>>
                PrepareAsyncGetNetworkState(::grpc::ClientContext *context,
                                            const ::cluster::rpc::NetworkStateRequest &request,
                                            ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                        ::cluster::rpc::NetworkStateResponse>>(
                        PrepareAsyncGetNetworkStateRaw(context, request, cq));
                }
                virtual ::grpc::Status GreetAsCandidate(::grpc::ClientContext *context,
                                                        const ::cluster::rpc::Request &request,
                                                        ::cluster::rpc::Response *response) = 0;
                std::unique_ptr<
                    ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response>>
                AsyncGreetAsCandidate(::grpc::ClientContext *context,
                                      const ::cluster::rpc::Request &request,
                                      ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response>>(
                        AsyncGreetAsCandidateRaw(context, request, cq));
                }
                std::unique_ptr<
                    ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response>>
                PrepareAsyncGreetAsCandidate(::grpc::ClientContext *context,
                                             const ::cluster::rpc::Request &request,
                                             ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response>>(
                        PrepareAsyncGreetAsCandidateRaw(context, request, cq));
                }
                virtual ::grpc::Status GreetAsLeader(::grpc::ClientContext *context,
                                                     const ::cluster::rpc::Request &request,
                                                     ::cluster::rpc::Response *response) = 0;
                std::unique_ptr<
                    ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response>>
                AsyncGreetAsLeader(::grpc::ClientContext *context,
                                   const ::cluster::rpc::Request &request,
                                   ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response>>(
                        AsyncGreetAsLeaderRaw(context, request, cq));
                }
                std::unique_ptr<
                    ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response>>
                PrepareAsyncGreetAsLeader(::grpc::ClientContext *context,
                                          const ::cluster::rpc::Request &request,
                                          ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response>>(
                        PrepareAsyncGreetAsLeaderRaw(context, request, cq));
                }
                virtual ::grpc::Status PulseMonitor(::grpc::ClientContext *context,
                                                    const ::cluster::rpc::Heartbeat &request,
                                                    ::cluster::rpc::Heartbeat *response) = 0;
                std::unique_ptr<
                    ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Heartbeat>>
                AsyncPulseMonitor(::grpc::ClientContext *context,
                                  const ::cluster::rpc::Heartbeat &request,
                                  ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Heartbeat>>(
                        AsyncPulseMonitorRaw(context, request, cq));
                }
                std::unique_ptr<
                    ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Heartbeat>>
                PrepareAsyncPulseMonitor(::grpc::ClientContext *context,
                                         const ::cluster::rpc::Heartbeat &request,
                                         ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Heartbeat>>(
                        PrepareAsyncPulseMonitorRaw(context, request, cq));
                }
                class experimental_async_interface {
                public:
                    virtual ~experimental_async_interface() {}
                    virtual void GetNetworkState(::grpc::ClientContext *context,
                                                 const ::cluster::rpc::NetworkStateRequest *request,
                                                 ::cluster::rpc::NetworkStateResponse *response,
                                                 std::function<void(::grpc::Status)>) = 0;
                    virtual void GetNetworkState(::grpc::ClientContext *context,
                                                 const ::grpc::ByteBuffer *request,
                                                 ::cluster::rpc::NetworkStateResponse *response,
                                                 std::function<void(::grpc::Status)>) = 0;
                    virtual void
                    GetNetworkState(::grpc::ClientContext *context,
                                    const ::cluster::rpc::NetworkStateRequest *request,
                                    ::cluster::rpc::NetworkStateResponse *response,
                                    ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
                    virtual void
                    GetNetworkState(::grpc::ClientContext *context,
                                    const ::grpc::ByteBuffer *request,
                                    ::cluster::rpc::NetworkStateResponse *response,
                                    ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
                    virtual void GreetAsCandidate(::grpc::ClientContext *context,
                                                  const ::cluster::rpc::Request *request,
                                                  ::cluster::rpc::Response *response,
                                                  std::function<void(::grpc::Status)>) = 0;
                    virtual void GreetAsCandidate(::grpc::ClientContext *context,
                                                  const ::grpc::ByteBuffer *request,
                                                  ::cluster::rpc::Response *response,
                                                  std::function<void(::grpc::Status)>) = 0;
                    virtual void
                    GreetAsCandidate(::grpc::ClientContext *context,
                                     const ::cluster::rpc::Request *request,
                                     ::cluster::rpc::Response *response,
                                     ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
                    virtual void
                    GreetAsCandidate(::grpc::ClientContext *context,
                                     const ::grpc::ByteBuffer *request,
                                     ::cluster::rpc::Response *response,
                                     ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
                    virtual void GreetAsLeader(::grpc::ClientContext *context,
                                               const ::cluster::rpc::Request *request,
                                               ::cluster::rpc::Response *response,
                                               std::function<void(::grpc::Status)>) = 0;
                    virtual void GreetAsLeader(::grpc::ClientContext *context,
                                               const ::grpc::ByteBuffer *request,
                                               ::cluster::rpc::Response *response,
                                               std::function<void(::grpc::Status)>) = 0;
                    virtual void
                    GreetAsLeader(::grpc::ClientContext *context,
                                  const ::cluster::rpc::Request *request,
                                  ::cluster::rpc::Response *response,
                                  ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
                    virtual void
                    GreetAsLeader(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request,
                                  ::cluster::rpc::Response *response,
                                  ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
                    virtual void PulseMonitor(::grpc::ClientContext *context,
                                              const ::cluster::rpc::Heartbeat *request,
                                              ::cluster::rpc::Heartbeat *response,
                                              std::function<void(::grpc::Status)>) = 0;
                    virtual void PulseMonitor(::grpc::ClientContext *context,
                                              const ::grpc::ByteBuffer *request,
                                              ::cluster::rpc::Heartbeat *response,
                                              std::function<void(::grpc::Status)>) = 0;
                    virtual void
                    PulseMonitor(::grpc::ClientContext *context,
                                 const ::cluster::rpc::Heartbeat *request,
                                 ::cluster::rpc::Heartbeat *response,
                                 ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
                    virtual void
                    PulseMonitor(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request,
                                 ::cluster::rpc::Heartbeat *response,
                                 ::grpc::experimental::ClientUnaryReactor *reactor) = 0;
                };
                virtual class experimental_async_interface *experimental_async() { return nullptr; }

            private:
                virtual ::grpc::ClientAsyncResponseReaderInterface<
                    ::cluster::rpc::NetworkStateResponse> *
                AsyncGetNetworkStateRaw(::grpc::ClientContext *context,
                                        const ::cluster::rpc::NetworkStateRequest &request,
                                        ::grpc::CompletionQueue *cq) = 0;
                virtual ::grpc::ClientAsyncResponseReaderInterface<
                    ::cluster::rpc::NetworkStateResponse> *
                PrepareAsyncGetNetworkStateRaw(::grpc::ClientContext *context,
                                               const ::cluster::rpc::NetworkStateRequest &request,
                                               ::grpc::CompletionQueue *cq) = 0;
                virtual ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response> *
                AsyncGreetAsCandidateRaw(::grpc::ClientContext *context,
                                         const ::cluster::rpc::Request &request,
                                         ::grpc::CompletionQueue *cq) = 0;
                virtual ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response> *
                PrepareAsyncGreetAsCandidateRaw(::grpc::ClientContext *context,
                                                const ::cluster::rpc::Request &request,
                                                ::grpc::CompletionQueue *cq) = 0;
                virtual ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response> *
                AsyncGreetAsLeaderRaw(::grpc::ClientContext *context,
                                      const ::cluster::rpc::Request &request,
                                      ::grpc::CompletionQueue *cq) = 0;
                virtual ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Response> *
                PrepareAsyncGreetAsLeaderRaw(::grpc::ClientContext *context,
                                             const ::cluster::rpc::Request &request,
                                             ::grpc::CompletionQueue *cq) = 0;
                virtual ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Heartbeat> *
                AsyncPulseMonitorRaw(::grpc::ClientContext *context,
                                     const ::cluster::rpc::Heartbeat &request,
                                     ::grpc::CompletionQueue *cq) = 0;
                virtual ::grpc::ClientAsyncResponseReaderInterface<::cluster::rpc::Heartbeat> *
                PrepareAsyncPulseMonitorRaw(::grpc::ClientContext *context,
                                            const ::cluster::rpc::Heartbeat &request,
                                            ::grpc::CompletionQueue *cq) = 0;
            };
            class Stub final : public StubInterface {
            public:
                Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel);
                ::grpc::Status
                GetNetworkState(::grpc::ClientContext *context,
                                const ::cluster::rpc::NetworkStateRequest &request,
                                ::cluster::rpc::NetworkStateResponse *response) override;
                std::unique_ptr<
                    ::grpc::ClientAsyncResponseReader<::cluster::rpc::NetworkStateResponse>>
                AsyncGetNetworkState(::grpc::ClientContext *context,
                                     const ::cluster::rpc::NetworkStateRequest &request,
                                     ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReader<::cluster::rpc::NetworkStateResponse>>(
                        AsyncGetNetworkStateRaw(context, request, cq));
                }
                std::unique_ptr<
                    ::grpc::ClientAsyncResponseReader<::cluster::rpc::NetworkStateResponse>>
                PrepareAsyncGetNetworkState(::grpc::ClientContext *context,
                                            const ::cluster::rpc::NetworkStateRequest &request,
                                            ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReader<::cluster::rpc::NetworkStateResponse>>(
                        PrepareAsyncGetNetworkStateRaw(context, request, cq));
                }
                ::grpc::Status GreetAsCandidate(::grpc::ClientContext *context,
                                                const ::cluster::rpc::Request &request,
                                                ::cluster::rpc::Response *response) override;
                std::unique_ptr<::grpc::ClientAsyncResponseReader<::cluster::rpc::Response>>
                AsyncGreetAsCandidate(::grpc::ClientContext *context,
                                      const ::cluster::rpc::Request &request,
                                      ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReader<::cluster::rpc::Response>>(
                        AsyncGreetAsCandidateRaw(context, request, cq));
                }
                std::unique_ptr<::grpc::ClientAsyncResponseReader<::cluster::rpc::Response>>
                PrepareAsyncGreetAsCandidate(::grpc::ClientContext *context,
                                             const ::cluster::rpc::Request &request,
                                             ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReader<::cluster::rpc::Response>>(
                        PrepareAsyncGreetAsCandidateRaw(context, request, cq));
                }
                ::grpc::Status GreetAsLeader(::grpc::ClientContext *context,
                                             const ::cluster::rpc::Request &request,
                                             ::cluster::rpc::Response *response) override;
                std::unique_ptr<::grpc::ClientAsyncResponseReader<::cluster::rpc::Response>>
                AsyncGreetAsLeader(::grpc::ClientContext *context,
                                   const ::cluster::rpc::Request &request,
                                   ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReader<::cluster::rpc::Response>>(
                        AsyncGreetAsLeaderRaw(context, request, cq));
                }
                std::unique_ptr<::grpc::ClientAsyncResponseReader<::cluster::rpc::Response>>
                PrepareAsyncGreetAsLeader(::grpc::ClientContext *context,
                                          const ::cluster::rpc::Request &request,
                                          ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReader<::cluster::rpc::Response>>(
                        PrepareAsyncGreetAsLeaderRaw(context, request, cq));
                }
                ::grpc::Status PulseMonitor(::grpc::ClientContext *context,
                                            const ::cluster::rpc::Heartbeat &request,
                                            ::cluster::rpc::Heartbeat *response) override;
                std::unique_ptr<::grpc::ClientAsyncResponseReader<::cluster::rpc::Heartbeat>>
                AsyncPulseMonitor(::grpc::ClientContext *context,
                                  const ::cluster::rpc::Heartbeat &request,
                                  ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReader<::cluster::rpc::Heartbeat>>(
                        AsyncPulseMonitorRaw(context, request, cq));
                }
                std::unique_ptr<::grpc::ClientAsyncResponseReader<::cluster::rpc::Heartbeat>>
                PrepareAsyncPulseMonitor(::grpc::ClientContext *context,
                                         const ::cluster::rpc::Heartbeat &request,
                                         ::grpc::CompletionQueue *cq) {
                    return std::unique_ptr<
                        ::grpc::ClientAsyncResponseReader<::cluster::rpc::Heartbeat>>(
                        PrepareAsyncPulseMonitorRaw(context, request, cq));
                }
                class experimental_async final
                    : public StubInterface::experimental_async_interface {
                public:
                    void GetNetworkState(::grpc::ClientContext *context,
                                         const ::cluster::rpc::NetworkStateRequest *request,
                                         ::cluster::rpc::NetworkStateResponse *response,
                                         std::function<void(::grpc::Status)>) override;
                    void GetNetworkState(::grpc::ClientContext *context,
                                         const ::grpc::ByteBuffer *request,
                                         ::cluster::rpc::NetworkStateResponse *response,
                                         std::function<void(::grpc::Status)>) override;
                    void
                    GetNetworkState(::grpc::ClientContext *context,
                                    const ::cluster::rpc::NetworkStateRequest *request,
                                    ::cluster::rpc::NetworkStateResponse *response,
                                    ::grpc::experimental::ClientUnaryReactor *reactor) override;
                    void
                    GetNetworkState(::grpc::ClientContext *context,
                                    const ::grpc::ByteBuffer *request,
                                    ::cluster::rpc::NetworkStateResponse *response,
                                    ::grpc::experimental::ClientUnaryReactor *reactor) override;
                    void GreetAsCandidate(::grpc::ClientContext *context,
                                          const ::cluster::rpc::Request *request,
                                          ::cluster::rpc::Response *response,
                                          std::function<void(::grpc::Status)>) override;
                    void GreetAsCandidate(::grpc::ClientContext *context,
                                          const ::grpc::ByteBuffer *request,
                                          ::cluster::rpc::Response *response,
                                          std::function<void(::grpc::Status)>) override;
                    void
                    GreetAsCandidate(::grpc::ClientContext *context,
                                     const ::cluster::rpc::Request *request,
                                     ::cluster::rpc::Response *response,
                                     ::grpc::experimental::ClientUnaryReactor *reactor) override;
                    void
                    GreetAsCandidate(::grpc::ClientContext *context,
                                     const ::grpc::ByteBuffer *request,
                                     ::cluster::rpc::Response *response,
                                     ::grpc::experimental::ClientUnaryReactor *reactor) override;
                    void GreetAsLeader(::grpc::ClientContext *context,
                                       const ::cluster::rpc::Request *request,
                                       ::cluster::rpc::Response *response,
                                       std::function<void(::grpc::Status)>) override;
                    void GreetAsLeader(::grpc::ClientContext *context,
                                       const ::grpc::ByteBuffer *request,
                                       ::cluster::rpc::Response *response,
                                       std::function<void(::grpc::Status)>) override;
                    void GreetAsLeader(::grpc::ClientContext *context,
                                       const ::cluster::rpc::Request *request,
                                       ::cluster::rpc::Response *response,
                                       ::grpc::experimental::ClientUnaryReactor *reactor) override;
                    void GreetAsLeader(::grpc::ClientContext *context,
                                       const ::grpc::ByteBuffer *request,
                                       ::cluster::rpc::Response *response,
                                       ::grpc::experimental::ClientUnaryReactor *reactor) override;
                    void PulseMonitor(::grpc::ClientContext *context,
                                      const ::cluster::rpc::Heartbeat *request,
                                      ::cluster::rpc::Heartbeat *response,
                                      std::function<void(::grpc::Status)>) override;
                    void PulseMonitor(::grpc::ClientContext *context,
                                      const ::grpc::ByteBuffer *request,
                                      ::cluster::rpc::Heartbeat *response,
                                      std::function<void(::grpc::Status)>) override;
                    void PulseMonitor(::grpc::ClientContext *context,
                                      const ::cluster::rpc::Heartbeat *request,
                                      ::cluster::rpc::Heartbeat *response,
                                      ::grpc::experimental::ClientUnaryReactor *reactor) override;
                    void PulseMonitor(::grpc::ClientContext *context,
                                      const ::grpc::ByteBuffer *request,
                                      ::cluster::rpc::Heartbeat *response,
                                      ::grpc::experimental::ClientUnaryReactor *reactor) override;

                private:
                    friend class Stub;
                    explicit experimental_async(Stub *stub)
                        : stub_(stub) {}
                    Stub *stub() { return stub_; }
                    Stub *stub_;
                };
                class experimental_async_interface *experimental_async() override {
                    return &async_stub_;
                }

            private:
                std::shared_ptr<::grpc::ChannelInterface> channel_;
                class experimental_async async_stub_ {
                    this
                };
                ::grpc::ClientAsyncResponseReader<::cluster::rpc::NetworkStateResponse> *
                AsyncGetNetworkStateRaw(::grpc::ClientContext *context,
                                        const ::cluster::rpc::NetworkStateRequest &request,
                                        ::grpc::CompletionQueue *cq) override;
                ::grpc::ClientAsyncResponseReader<::cluster::rpc::NetworkStateResponse> *
                PrepareAsyncGetNetworkStateRaw(::grpc::ClientContext *context,
                                               const ::cluster::rpc::NetworkStateRequest &request,
                                               ::grpc::CompletionQueue *cq) override;
                ::grpc::ClientAsyncResponseReader<::cluster::rpc::Response> *
                AsyncGreetAsCandidateRaw(::grpc::ClientContext *context,
                                         const ::cluster::rpc::Request &request,
                                         ::grpc::CompletionQueue *cq) override;
                ::grpc::ClientAsyncResponseReader<::cluster::rpc::Response> *
                PrepareAsyncGreetAsCandidateRaw(::grpc::ClientContext *context,
                                                const ::cluster::rpc::Request &request,
                                                ::grpc::CompletionQueue *cq) override;
                ::grpc::ClientAsyncResponseReader<::cluster::rpc::Response> *
                AsyncGreetAsLeaderRaw(::grpc::ClientContext *context,
                                      const ::cluster::rpc::Request &request,
                                      ::grpc::CompletionQueue *cq) override;
                ::grpc::ClientAsyncResponseReader<::cluster::rpc::Response> *
                PrepareAsyncGreetAsLeaderRaw(::grpc::ClientContext *context,
                                             const ::cluster::rpc::Request &request,
                                             ::grpc::CompletionQueue *cq) override;
                ::grpc::ClientAsyncResponseReader<::cluster::rpc::Heartbeat> *
                AsyncPulseMonitorRaw(::grpc::ClientContext *context,
                                     const ::cluster::rpc::Heartbeat &request,
                                     ::grpc::CompletionQueue *cq) override;
                ::grpc::ClientAsyncResponseReader<::cluster::rpc::Heartbeat> *
                PrepareAsyncPulseMonitorRaw(::grpc::ClientContext *context,
                                            const ::cluster::rpc::Heartbeat &request,
                                            ::grpc::CompletionQueue *cq) override;
                const ::grpc::internal::RpcMethod rpcmethod_GetNetworkState_;
                const ::grpc::internal::RpcMethod rpcmethod_GreetAsCandidate_;
                const ::grpc::internal::RpcMethod rpcmethod_GreetAsLeader_;
                const ::grpc::internal::RpcMethod rpcmethod_PulseMonitor_;
            };
            static std::unique_ptr<Stub>
            NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
                    const ::grpc::StubOptions &options = ::grpc::StubOptions());

            class Service : public ::grpc::Service {
            public:
                Service();
                virtual ~Service();
                virtual ::grpc::Status
                GetNetworkState(::grpc::ServerContext *context,
                                const ::cluster::rpc::NetworkStateRequest *request,
                                ::cluster::rpc::NetworkStateResponse *response);
                virtual ::grpc::Status GreetAsCandidate(::grpc::ServerContext *context,
                                                        const ::cluster::rpc::Request *request,
                                                        ::cluster::rpc::Response *response);
                virtual ::grpc::Status GreetAsLeader(::grpc::ServerContext *context,
                                                     const ::cluster::rpc::Request *request,
                                                     ::cluster::rpc::Response *response);
                virtual ::grpc::Status PulseMonitor(::grpc::ServerContext *context,
                                                    const ::cluster::rpc::Heartbeat *request,
                                                    ::cluster::rpc::Heartbeat *response);
            };
            template <class BaseClass> class WithAsyncMethod_GetNetworkState : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithAsyncMethod_GetNetworkState() { ::grpc::Service::MarkMethodAsync(0); }
                ~WithAsyncMethod_GetNetworkState() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status
                GetNetworkState(::grpc::ServerContext * /*context*/,
                                const ::cluster::rpc::NetworkStateRequest * /*request*/,
                                ::cluster::rpc::NetworkStateResponse * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                void RequestGetNetworkState(
                    ::grpc::ServerContext *context, ::cluster::rpc::NetworkStateRequest *request,
                    ::grpc::ServerAsyncResponseWriter<::cluster::rpc::NetworkStateResponse>
                        *response,
                    ::grpc::CompletionQueue *new_call_cq,
                    ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                    ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq,
                                                       notification_cq, tag);
                }
            };
            template <class BaseClass> class WithAsyncMethod_GreetAsCandidate : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithAsyncMethod_GreetAsCandidate() { ::grpc::Service::MarkMethodAsync(1); }
                ~WithAsyncMethod_GreetAsCandidate() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status GreetAsCandidate(::grpc::ServerContext * /*context*/,
                                                const ::cluster::rpc::Request * /*request*/,
                                                ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                void RequestGreetAsCandidate(
                    ::grpc::ServerContext *context, ::cluster::rpc::Request *request,
                    ::grpc::ServerAsyncResponseWriter<::cluster::rpc::Response> *response,
                    ::grpc::CompletionQueue *new_call_cq,
                    ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                    ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq,
                                                       notification_cq, tag);
                }
            };
            template <class BaseClass> class WithAsyncMethod_GreetAsLeader : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithAsyncMethod_GreetAsLeader() { ::grpc::Service::MarkMethodAsync(2); }
                ~WithAsyncMethod_GreetAsLeader() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status GreetAsLeader(::grpc::ServerContext * /*context*/,
                                             const ::cluster::rpc::Request * /*request*/,
                                             ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                void RequestGreetAsLeader(
                    ::grpc::ServerContext *context, ::cluster::rpc::Request *request,
                    ::grpc::ServerAsyncResponseWriter<::cluster::rpc::Response> *response,
                    ::grpc::CompletionQueue *new_call_cq,
                    ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                    ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq,
                                                       notification_cq, tag);
                }
            };
            template <class BaseClass> class WithAsyncMethod_PulseMonitor : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithAsyncMethod_PulseMonitor() { ::grpc::Service::MarkMethodAsync(3); }
                ~WithAsyncMethod_PulseMonitor() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status PulseMonitor(::grpc::ServerContext * /*context*/,
                                            const ::cluster::rpc::Heartbeat * /*request*/,
                                            ::cluster::rpc::Heartbeat * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                void RequestPulseMonitor(
                    ::grpc::ServerContext *context, ::cluster::rpc::Heartbeat *request,
                    ::grpc::ServerAsyncResponseWriter<::cluster::rpc::Heartbeat> *response,
                    ::grpc::CompletionQueue *new_call_cq,
                    ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                    ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq,
                                                       notification_cq, tag);
                }
            };
            typedef WithAsyncMethod_GetNetworkState<WithAsyncMethod_GreetAsCandidate<
                WithAsyncMethod_GreetAsLeader<WithAsyncMethod_PulseMonitor<Service>>>>
                AsyncService;
            template <class BaseClass>
            class ExperimentalWithCallbackMethod_GetNetworkState : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                ExperimentalWithCallbackMethod_GetNetworkState() {
                    ::grpc::Service::experimental().MarkMethodCallback(
                        0,
                        new ::grpc_impl::internal::CallbackUnaryHandler<
                            ::cluster::rpc::NetworkStateRequest,
                            ::cluster::rpc::NetworkStateResponse>(
                            [this](::grpc::ServerContext *context,
                                   const ::cluster::rpc::NetworkStateRequest *request,
                                   ::cluster::rpc::NetworkStateResponse *response,
                                   ::grpc::experimental::ServerCallbackRpcController *controller) {
                                return this->GetNetworkState(context, request, response,
                                                             controller);
                            }));
                }
                void SetMessageAllocatorFor_GetNetworkState(
                    ::grpc::experimental::MessageAllocator<::cluster::rpc::NetworkStateRequest,
                                                           ::cluster::rpc::NetworkStateResponse>
                        *allocator) {
                    static_cast<::grpc_impl::internal::CallbackUnaryHandler<
                        ::cluster::rpc::NetworkStateRequest, ::cluster::rpc::NetworkStateResponse>
                                    *>(::grpc::Service::experimental().GetHandler(0))
                        ->SetMessageAllocator(allocator);
                }
                ~ExperimentalWithCallbackMethod_GetNetworkState() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status
                GetNetworkState(::grpc::ServerContext * /*context*/,
                                const ::cluster::rpc::NetworkStateRequest * /*request*/,
                                ::cluster::rpc::NetworkStateResponse * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                virtual void
                GetNetworkState(::grpc::ServerContext * /*context*/,
                                const ::cluster::rpc::NetworkStateRequest * /*request*/,
                                ::cluster::rpc::NetworkStateResponse * /*response*/,
                                ::grpc::experimental::ServerCallbackRpcController *controller) {
                    controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
                }
            };
            template <class BaseClass>
            class ExperimentalWithCallbackMethod_GreetAsCandidate : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                ExperimentalWithCallbackMethod_GreetAsCandidate() {
                    ::grpc::Service::experimental().MarkMethodCallback(
                        1,
                        new ::grpc_impl::internal::CallbackUnaryHandler<::cluster::rpc::Request,
                                                                        ::cluster::rpc::Response>(
                            [this](::grpc::ServerContext *context,
                                   const ::cluster::rpc::Request *request,
                                   ::cluster::rpc::Response *response,
                                   ::grpc::experimental::ServerCallbackRpcController *controller) {
                                return this->GreetAsCandidate(context, request, response,
                                                              controller);
                            }));
                }
                void SetMessageAllocatorFor_GreetAsCandidate(
                    ::grpc::experimental::MessageAllocator<::cluster::rpc::Request,
                                                           ::cluster::rpc::Response> *allocator) {
                    static_cast<::grpc_impl::internal::CallbackUnaryHandler<
                        ::cluster::rpc::Request, ::cluster::rpc::Response> *>(
                        ::grpc::Service::experimental().GetHandler(1))
                        ->SetMessageAllocator(allocator);
                }
                ~ExperimentalWithCallbackMethod_GreetAsCandidate() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status GreetAsCandidate(::grpc::ServerContext * /*context*/,
                                                const ::cluster::rpc::Request * /*request*/,
                                                ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                virtual void
                GreetAsCandidate(::grpc::ServerContext * /*context*/,
                                 const ::cluster::rpc::Request * /*request*/,
                                 ::cluster::rpc::Response * /*response*/,
                                 ::grpc::experimental::ServerCallbackRpcController *controller) {
                    controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
                }
            };
            template <class BaseClass>
            class ExperimentalWithCallbackMethod_GreetAsLeader : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                ExperimentalWithCallbackMethod_GreetAsLeader() {
                    ::grpc::Service::experimental().MarkMethodCallback(
                        2,
                        new ::grpc_impl::internal::CallbackUnaryHandler<::cluster::rpc::Request,
                                                                        ::cluster::rpc::Response>(
                            [this](::grpc::ServerContext *context,
                                   const ::cluster::rpc::Request *request,
                                   ::cluster::rpc::Response *response,
                                   ::grpc::experimental::ServerCallbackRpcController *controller) {
                                return this->GreetAsLeader(context, request, response, controller);
                            }));
                }
                void SetMessageAllocatorFor_GreetAsLeader(
                    ::grpc::experimental::MessageAllocator<::cluster::rpc::Request,
                                                           ::cluster::rpc::Response> *allocator) {
                    static_cast<::grpc_impl::internal::CallbackUnaryHandler<
                        ::cluster::rpc::Request, ::cluster::rpc::Response> *>(
                        ::grpc::Service::experimental().GetHandler(2))
                        ->SetMessageAllocator(allocator);
                }
                ~ExperimentalWithCallbackMethod_GreetAsLeader() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status GreetAsLeader(::grpc::ServerContext * /*context*/,
                                             const ::cluster::rpc::Request * /*request*/,
                                             ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                virtual void
                GreetAsLeader(::grpc::ServerContext * /*context*/,
                              const ::cluster::rpc::Request * /*request*/,
                              ::cluster::rpc::Response * /*response*/,
                              ::grpc::experimental::ServerCallbackRpcController *controller) {
                    controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
                }
            };
            template <class BaseClass>
            class ExperimentalWithCallbackMethod_PulseMonitor : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                ExperimentalWithCallbackMethod_PulseMonitor() {
                    ::grpc::Service::experimental().MarkMethodCallback(
                        3,
                        new ::grpc_impl::internal::CallbackUnaryHandler<::cluster::rpc::Heartbeat,
                                                                        ::cluster::rpc::Heartbeat>(
                            [this](::grpc::ServerContext *context,
                                   const ::cluster::rpc::Heartbeat *request,
                                   ::cluster::rpc::Heartbeat *response,
                                   ::grpc::experimental::ServerCallbackRpcController *controller) {
                                return this->PulseMonitor(context, request, response, controller);
                            }));
                }
                void SetMessageAllocatorFor_PulseMonitor(
                    ::grpc::experimental::MessageAllocator<::cluster::rpc::Heartbeat,
                                                           ::cluster::rpc::Heartbeat> *allocator) {
                    static_cast<::grpc_impl::internal::CallbackUnaryHandler<
                        ::cluster::rpc::Heartbeat, ::cluster::rpc::Heartbeat> *>(
                        ::grpc::Service::experimental().GetHandler(3))
                        ->SetMessageAllocator(allocator);
                }
                ~ExperimentalWithCallbackMethod_PulseMonitor() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status PulseMonitor(::grpc::ServerContext * /*context*/,
                                            const ::cluster::rpc::Heartbeat * /*request*/,
                                            ::cluster::rpc::Heartbeat * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                virtual void
                PulseMonitor(::grpc::ServerContext * /*context*/,
                             const ::cluster::rpc::Heartbeat * /*request*/,
                             ::cluster::rpc::Heartbeat * /*response*/,
                             ::grpc::experimental::ServerCallbackRpcController *controller) {
                    controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
                }
            };
            typedef ExperimentalWithCallbackMethod_GetNetworkState<
                ExperimentalWithCallbackMethod_GreetAsCandidate<
                    ExperimentalWithCallbackMethod_GreetAsLeader<
                        ExperimentalWithCallbackMethod_PulseMonitor<Service>>>>
                ExperimentalCallbackService;
            template <class BaseClass> class WithGenericMethod_GetNetworkState : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithGenericMethod_GetNetworkState() { ::grpc::Service::MarkMethodGeneric(0); }
                ~WithGenericMethod_GetNetworkState() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status
                GetNetworkState(::grpc::ServerContext * /*context*/,
                                const ::cluster::rpc::NetworkStateRequest * /*request*/,
                                ::cluster::rpc::NetworkStateResponse * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
            };
            template <class BaseClass> class WithGenericMethod_GreetAsCandidate : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithGenericMethod_GreetAsCandidate() { ::grpc::Service::MarkMethodGeneric(1); }
                ~WithGenericMethod_GreetAsCandidate() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status GreetAsCandidate(::grpc::ServerContext * /*context*/,
                                                const ::cluster::rpc::Request * /*request*/,
                                                ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
            };
            template <class BaseClass> class WithGenericMethod_GreetAsLeader : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithGenericMethod_GreetAsLeader() { ::grpc::Service::MarkMethodGeneric(2); }
                ~WithGenericMethod_GreetAsLeader() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status GreetAsLeader(::grpc::ServerContext * /*context*/,
                                             const ::cluster::rpc::Request * /*request*/,
                                             ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
            };
            template <class BaseClass> class WithGenericMethod_PulseMonitor : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithGenericMethod_PulseMonitor() { ::grpc::Service::MarkMethodGeneric(3); }
                ~WithGenericMethod_PulseMonitor() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status PulseMonitor(::grpc::ServerContext * /*context*/,
                                            const ::cluster::rpc::Heartbeat * /*request*/,
                                            ::cluster::rpc::Heartbeat * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
            };
            template <class BaseClass> class WithRawMethod_GetNetworkState : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithRawMethod_GetNetworkState() { ::grpc::Service::MarkMethodRaw(0); }
                ~WithRawMethod_GetNetworkState() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status
                GetNetworkState(::grpc::ServerContext * /*context*/,
                                const ::cluster::rpc::NetworkStateRequest * /*request*/,
                                ::cluster::rpc::NetworkStateResponse * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                void RequestGetNetworkState(
                    ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                    ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                    ::grpc::CompletionQueue *new_call_cq,
                    ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                    ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq,
                                                       notification_cq, tag);
                }
            };
            template <class BaseClass> class WithRawMethod_GreetAsCandidate : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithRawMethod_GreetAsCandidate() { ::grpc::Service::MarkMethodRaw(1); }
                ~WithRawMethod_GreetAsCandidate() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status GreetAsCandidate(::grpc::ServerContext * /*context*/,
                                                const ::cluster::rpc::Request * /*request*/,
                                                ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                void RequestGreetAsCandidate(
                    ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                    ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                    ::grpc::CompletionQueue *new_call_cq,
                    ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                    ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq,
                                                       notification_cq, tag);
                }
            };
            template <class BaseClass> class WithRawMethod_GreetAsLeader : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithRawMethod_GreetAsLeader() { ::grpc::Service::MarkMethodRaw(2); }
                ~WithRawMethod_GreetAsLeader() override { BaseClassMustBeDerivedFromService(this); }
                // disable synchronous version of this method
                ::grpc::Status GreetAsLeader(::grpc::ServerContext * /*context*/,
                                             const ::cluster::rpc::Request * /*request*/,
                                             ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                void RequestGreetAsLeader(
                    ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                    ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                    ::grpc::CompletionQueue *new_call_cq,
                    ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                    ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq,
                                                       notification_cq, tag);
                }
            };
            template <class BaseClass> class WithRawMethod_PulseMonitor : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithRawMethod_PulseMonitor() { ::grpc::Service::MarkMethodRaw(3); }
                ~WithRawMethod_PulseMonitor() override { BaseClassMustBeDerivedFromService(this); }
                // disable synchronous version of this method
                ::grpc::Status PulseMonitor(::grpc::ServerContext * /*context*/,
                                            const ::cluster::rpc::Heartbeat * /*request*/,
                                            ::cluster::rpc::Heartbeat * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                void
                RequestPulseMonitor(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                                    ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                                    ::grpc::CompletionQueue *new_call_cq,
                                    ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                    ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq,
                                                       notification_cq, tag);
                }
            };
            template <class BaseClass>
            class ExperimentalWithRawCallbackMethod_GetNetworkState : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                ExperimentalWithRawCallbackMethod_GetNetworkState() {
                    ::grpc::Service::experimental().MarkMethodRawCallback(
                        0,
                        new ::grpc_impl::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                                        ::grpc::ByteBuffer>(
                            [this](::grpc::ServerContext *context,
                                   const ::grpc::ByteBuffer *request, ::grpc::ByteBuffer *response,
                                   ::grpc::experimental::ServerCallbackRpcController *controller) {
                                this->GetNetworkState(context, request, response, controller);
                            }));
                }
                ~ExperimentalWithRawCallbackMethod_GetNetworkState() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status
                GetNetworkState(::grpc::ServerContext * /*context*/,
                                const ::cluster::rpc::NetworkStateRequest * /*request*/,
                                ::cluster::rpc::NetworkStateResponse * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                virtual void
                GetNetworkState(::grpc::ServerContext * /*context*/,
                                const ::grpc::ByteBuffer * /*request*/,
                                ::grpc::ByteBuffer * /*response*/,
                                ::grpc::experimental::ServerCallbackRpcController *controller) {
                    controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
                }
            };
            template <class BaseClass>
            class ExperimentalWithRawCallbackMethod_GreetAsCandidate : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                ExperimentalWithRawCallbackMethod_GreetAsCandidate() {
                    ::grpc::Service::experimental().MarkMethodRawCallback(
                        1,
                        new ::grpc_impl::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                                        ::grpc::ByteBuffer>(
                            [this](::grpc::ServerContext *context,
                                   const ::grpc::ByteBuffer *request, ::grpc::ByteBuffer *response,
                                   ::grpc::experimental::ServerCallbackRpcController *controller) {
                                this->GreetAsCandidate(context, request, response, controller);
                            }));
                }
                ~ExperimentalWithRawCallbackMethod_GreetAsCandidate() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status GreetAsCandidate(::grpc::ServerContext * /*context*/,
                                                const ::cluster::rpc::Request * /*request*/,
                                                ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                virtual void
                GreetAsCandidate(::grpc::ServerContext * /*context*/,
                                 const ::grpc::ByteBuffer * /*request*/,
                                 ::grpc::ByteBuffer * /*response*/,
                                 ::grpc::experimental::ServerCallbackRpcController *controller) {
                    controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
                }
            };
            template <class BaseClass>
            class ExperimentalWithRawCallbackMethod_GreetAsLeader : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                ExperimentalWithRawCallbackMethod_GreetAsLeader() {
                    ::grpc::Service::experimental().MarkMethodRawCallback(
                        2,
                        new ::grpc_impl::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                                        ::grpc::ByteBuffer>(
                            [this](::grpc::ServerContext *context,
                                   const ::grpc::ByteBuffer *request, ::grpc::ByteBuffer *response,
                                   ::grpc::experimental::ServerCallbackRpcController *controller) {
                                this->GreetAsLeader(context, request, response, controller);
                            }));
                }
                ~ExperimentalWithRawCallbackMethod_GreetAsLeader() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status GreetAsLeader(::grpc::ServerContext * /*context*/,
                                             const ::cluster::rpc::Request * /*request*/,
                                             ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                virtual void
                GreetAsLeader(::grpc::ServerContext * /*context*/,
                              const ::grpc::ByteBuffer * /*request*/,
                              ::grpc::ByteBuffer * /*response*/,
                              ::grpc::experimental::ServerCallbackRpcController *controller) {
                    controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
                }
            };
            template <class BaseClass>
            class ExperimentalWithRawCallbackMethod_PulseMonitor : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                ExperimentalWithRawCallbackMethod_PulseMonitor() {
                    ::grpc::Service::experimental().MarkMethodRawCallback(
                        3,
                        new ::grpc_impl::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                                        ::grpc::ByteBuffer>(
                            [this](::grpc::ServerContext *context,
                                   const ::grpc::ByteBuffer *request, ::grpc::ByteBuffer *response,
                                   ::grpc::experimental::ServerCallbackRpcController *controller) {
                                this->PulseMonitor(context, request, response, controller);
                            }));
                }
                ~ExperimentalWithRawCallbackMethod_PulseMonitor() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable synchronous version of this method
                ::grpc::Status PulseMonitor(::grpc::ServerContext * /*context*/,
                                            const ::cluster::rpc::Heartbeat * /*request*/,
                                            ::cluster::rpc::Heartbeat * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                virtual void
                PulseMonitor(::grpc::ServerContext * /*context*/,
                             const ::grpc::ByteBuffer * /*request*/,
                             ::grpc::ByteBuffer * /*response*/,
                             ::grpc::experimental::ServerCallbackRpcController *controller) {
                    controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
                }
            };
            template <class BaseClass>
            class WithStreamedUnaryMethod_GetNetworkState : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithStreamedUnaryMethod_GetNetworkState() {
                    ::grpc::Service::MarkMethodStreamed(
                        0, new ::grpc::internal::StreamedUnaryHandler<
                               ::cluster::rpc::NetworkStateRequest,
                               ::cluster::rpc::NetworkStateResponse>(
                               std::bind(&WithStreamedUnaryMethod_GetNetworkState<
                                             BaseClass>::StreamedGetNetworkState,
                                         this, std::placeholders::_1, std::placeholders::_2)));
                }
                ~WithStreamedUnaryMethod_GetNetworkState() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable regular version of this method
                ::grpc::Status
                GetNetworkState(::grpc::ServerContext * /*context*/,
                                const ::cluster::rpc::NetworkStateRequest * /*request*/,
                                ::cluster::rpc::NetworkStateResponse * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                // replace default version of method with streamed unary
                virtual ::grpc::Status StreamedGetNetworkState(
                    ::grpc::ServerContext *context,
                    ::grpc::ServerUnaryStreamer<::cluster::rpc::NetworkStateRequest,
                                                ::cluster::rpc::NetworkStateResponse>
                        *server_unary_streamer) = 0;
            };
            template <class BaseClass>
            class WithStreamedUnaryMethod_GreetAsCandidate : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithStreamedUnaryMethod_GreetAsCandidate() {
                    ::grpc::Service::MarkMethodStreamed(
                        1, new ::grpc::internal::StreamedUnaryHandler<::cluster::rpc::Request,
                                                                      ::cluster::rpc::Response>(
                               std::bind(&WithStreamedUnaryMethod_GreetAsCandidate<
                                             BaseClass>::StreamedGreetAsCandidate,
                                         this, std::placeholders::_1, std::placeholders::_2)));
                }
                ~WithStreamedUnaryMethod_GreetAsCandidate() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable regular version of this method
                ::grpc::Status GreetAsCandidate(::grpc::ServerContext * /*context*/,
                                                const ::cluster::rpc::Request * /*request*/,
                                                ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                // replace default version of method with streamed unary
                virtual ::grpc::Status StreamedGreetAsCandidate(
                    ::grpc::ServerContext *context,
                    ::grpc::ServerUnaryStreamer<::cluster::rpc::Request, ::cluster::rpc::Response>
                        *server_unary_streamer) = 0;
            };
            template <class BaseClass>
            class WithStreamedUnaryMethod_GreetAsLeader : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithStreamedUnaryMethod_GreetAsLeader() {
                    ::grpc::Service::MarkMethodStreamed(
                        2, new ::grpc::internal::StreamedUnaryHandler<::cluster::rpc::Request,
                                                                      ::cluster::rpc::Response>(
                               std::bind(&WithStreamedUnaryMethod_GreetAsLeader<
                                             BaseClass>::StreamedGreetAsLeader,
                                         this, std::placeholders::_1, std::placeholders::_2)));
                }
                ~WithStreamedUnaryMethod_GreetAsLeader() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable regular version of this method
                ::grpc::Status GreetAsLeader(::grpc::ServerContext * /*context*/,
                                             const ::cluster::rpc::Request * /*request*/,
                                             ::cluster::rpc::Response * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                // replace default version of method with streamed unary
                virtual ::grpc::Status StreamedGreetAsLeader(
                    ::grpc::ServerContext *context,
                    ::grpc::ServerUnaryStreamer<::cluster::rpc::Request, ::cluster::rpc::Response>
                        *server_unary_streamer) = 0;
            };
            template <class BaseClass>
            class WithStreamedUnaryMethod_PulseMonitor : public BaseClass {
            private:
                void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

            public:
                WithStreamedUnaryMethod_PulseMonitor() {
                    ::grpc::Service::MarkMethodStreamed(
                        3,
                        new ::grpc::internal::StreamedUnaryHandler<
                            ::cluster::rpc::Heartbeat, ::cluster::rpc::Heartbeat>(std::bind(
                            &WithStreamedUnaryMethod_PulseMonitor<BaseClass>::StreamedPulseMonitor,
                            this, std::placeholders::_1, std::placeholders::_2)));
                }
                ~WithStreamedUnaryMethod_PulseMonitor() override {
                    BaseClassMustBeDerivedFromService(this);
                }
                // disable regular version of this method
                ::grpc::Status PulseMonitor(::grpc::ServerContext * /*context*/,
                                            const ::cluster::rpc::Heartbeat * /*request*/,
                                            ::cluster::rpc::Heartbeat * /*response*/) override {
                    abort();
                    return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
                }
                // replace default version of method with streamed unary
                virtual ::grpc::Status
                StreamedPulseMonitor(::grpc::ServerContext *context,
                                     ::grpc::ServerUnaryStreamer<::cluster::rpc::Heartbeat,
                                                                 ::cluster::rpc::Heartbeat>
                                         *server_unary_streamer) = 0;
            };
            typedef WithStreamedUnaryMethod_GetNetworkState<
                WithStreamedUnaryMethod_GreetAsCandidate<WithStreamedUnaryMethod_GreetAsLeader<
                    WithStreamedUnaryMethod_PulseMonitor<Service>>>>
                StreamedUnaryService;
            typedef Service SplitStreamedService;
            typedef WithStreamedUnaryMethod_GetNetworkState<
                WithStreamedUnaryMethod_GreetAsCandidate<WithStreamedUnaryMethod_GreetAsLeader<
                    WithStreamedUnaryMethod_PulseMonitor<Service>>>>
                StreamedService;
        };

    } // namespace rpc
} // namespace cluster

#endif // GRPC_rpc_2fleader_2eproto__INCLUDED
