// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc/leader.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rpc_2fleader_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rpc_2fleader_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/message.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/port_undef.inc>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rpc_2fleader_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
    class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rpc_2fleader_2eproto {
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField
        entries[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField
        aux[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable
        schema[7] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
    static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
    static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_rpc_2fleader_2eproto;
namespace cluster {
    namespace rpc {
        class ClusterId;
        class ClusterIdDefaultTypeInternal;
        extern ClusterIdDefaultTypeInternal _ClusterId_default_instance_;
        class Heartbeat;
        class HeartbeatDefaultTypeInternal;
        extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
        class NetworkStateRequest;
        class NetworkStateRequestDefaultTypeInternal;
        extern NetworkStateRequestDefaultTypeInternal _NetworkStateRequest_default_instance_;
        class NetworkStateResponse;
        class NetworkStateResponseDefaultTypeInternal;
        extern NetworkStateResponseDefaultTypeInternal _NetworkStateResponse_default_instance_;
        class Request;
        class RequestDefaultTypeInternal;
        extern RequestDefaultTypeInternal _Request_default_instance_;
        class Response;
        class ResponseDefaultTypeInternal;
        extern ResponseDefaultTypeInternal _Response_default_instance_;
        class Term;
        class TermDefaultTypeInternal;
        extern TermDefaultTypeInternal _Term_default_instance_;
    } // namespace rpc
} // namespace cluster
PROTOBUF_NAMESPACE_OPEN
template <>::cluster::rpc::ClusterId *Arena::CreateMaybeMessage<::cluster::rpc::ClusterId>(Arena *);
template <>::cluster::rpc::Heartbeat *Arena::CreateMaybeMessage<::cluster::rpc::Heartbeat>(Arena *);
template <>
::cluster::rpc::NetworkStateRequest *
Arena::CreateMaybeMessage<::cluster::rpc::NetworkStateRequest>(Arena *);
template <>
::cluster::rpc::NetworkStateResponse *
Arena::CreateMaybeMessage<::cluster::rpc::NetworkStateResponse>(Arena *);
template <>::cluster::rpc::Request *Arena::CreateMaybeMessage<::cluster::rpc::Request>(Arena *);
template <>::cluster::rpc::Response *Arena::CreateMaybeMessage<::cluster::rpc::Response>(Arena *);
template <>::cluster::rpc::Term *Arena::CreateMaybeMessage<::cluster::rpc::Term>(Arena *);
PROTOBUF_NAMESPACE_CLOSE
namespace cluster {
    namespace rpc {

        // ===================================================================

        class Term : public ::PROTOBUF_NAMESPACE_ID::
                         Message /* @@protoc_insertion_point(class_definition:cluster.rpc.Term) */ {
        public:
            Term();
            virtual ~Term();

            Term(const Term &from);
            Term(Term &&from) noexcept
                : Term() {
                *this = ::std::move(from);
            }

            inline Term &operator=(const Term &from) {
                CopyFrom(from);
                return *this;
            }
            inline Term &operator=(Term &&from) noexcept {
                if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                    if (this != &from)
                        InternalSwap(&from);
                } else {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                return GetDescriptor();
            }
            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                return GetMetadataStatic().descriptor;
            }
            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                return GetMetadataStatic().reflection;
            }
            static const Term &default_instance();

            static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
            static inline const Term *internal_default_instance() {
                return reinterpret_cast<const Term *>(&_Term_default_instance_);
            }
            static constexpr int kIndexInFileMessages = 0;

            void Swap(Term *other);
            friend void swap(Term &a, Term &b) { a.Swap(&b); }

            // implements Message ----------------------------------------------

            inline Term *New() const final { return CreateMaybeMessage<Term>(nullptr); }

            Term *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                return CreateMaybeMessage<Term>(arena);
            }
            void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void CopyFrom(const Term &from);
            void MergeFrom(const Term &from);
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            const char *_InternalParse(const char *ptr,
                                       ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
#else
            bool
            MergePartialFromCodedStream(::PROTOBUF_NAMESPACE_ID::io::CodedInputStream *input) final;
#endif // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            void SerializeWithCachedSizes(
                ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream *output) const final;
            ::PROTOBUF_NAMESPACE_ID::uint8 *InternalSerializeWithCachedSizesToArray(
                ::PROTOBUF_NAMESPACE_ID::uint8 *target) const final;
            int GetCachedSize() const final { return _cached_size_.Get(); }

        private:
            inline void SharedCtor();
            inline void SharedDtor();
            void SetCachedSize(int size) const final;
            void InternalSwap(Term *other);
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                return "cluster.rpc.Term";
            }

        private:
            inline ::PROTOBUF_NAMESPACE_ID::Arena *GetArenaNoVirtual() const { return nullptr; }
            inline void *MaybeArenaPtr() const { return nullptr; }

        public:
            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        private:
            static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
                ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
                    &::descriptor_table_rpc_2fleader_2eproto);
                return ::descriptor_table_rpc_2fleader_2eproto
                    .file_level_metadata[kIndexInFileMessages];
            }

        public:
            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // repeated uint64 counter = 1;
            int counter_size() const;
            void clear_counter();
            static const int kCounterFieldNumber = 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 counter(int index) const;
            void set_counter(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
            void add_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
            const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::PROTOBUF_NAMESPACE_ID::uint64> &
            counter() const;
            ::PROTOBUF_NAMESPACE_ID::RepeatedField<::PROTOBUF_NAMESPACE_ID::uint64> *
            mutable_counter();

            // @@protoc_insertion_point(class_scope:cluster.rpc.Term)
        private:
            class HasBitSetters;

            ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
            ::PROTOBUF_NAMESPACE_ID::RepeatedField<::PROTOBUF_NAMESPACE_ID::uint64> counter_;
            mutable std::atomic<int> _counter_cached_byte_size_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_rpc_2fleader_2eproto;
        };
        // -------------------------------------------------------------------

        class ClusterId
            : public ::PROTOBUF_NAMESPACE_ID::
                  Message /* @@protoc_insertion_point(class_definition:cluster.rpc.ClusterId) */ {
        public:
            ClusterId();
            virtual ~ClusterId();

            ClusterId(const ClusterId &from);
            ClusterId(ClusterId &&from) noexcept
                : ClusterId() {
                *this = ::std::move(from);
            }

            inline ClusterId &operator=(const ClusterId &from) {
                CopyFrom(from);
                return *this;
            }
            inline ClusterId &operator=(ClusterId &&from) noexcept {
                if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                    if (this != &from)
                        InternalSwap(&from);
                } else {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                return GetDescriptor();
            }
            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                return GetMetadataStatic().descriptor;
            }
            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                return GetMetadataStatic().reflection;
            }
            static const ClusterId &default_instance();

            static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
            static inline const ClusterId *internal_default_instance() {
                return reinterpret_cast<const ClusterId *>(&_ClusterId_default_instance_);
            }
            static constexpr int kIndexInFileMessages = 1;

            void Swap(ClusterId *other);
            friend void swap(ClusterId &a, ClusterId &b) { a.Swap(&b); }

            // implements Message ----------------------------------------------

            inline ClusterId *New() const final { return CreateMaybeMessage<ClusterId>(nullptr); }

            ClusterId *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                return CreateMaybeMessage<ClusterId>(arena);
            }
            void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void CopyFrom(const ClusterId &from);
            void MergeFrom(const ClusterId &from);
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            const char *_InternalParse(const char *ptr,
                                       ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
#else
            bool
            MergePartialFromCodedStream(::PROTOBUF_NAMESPACE_ID::io::CodedInputStream *input) final;
#endif // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            void SerializeWithCachedSizes(
                ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream *output) const final;
            ::PROTOBUF_NAMESPACE_ID::uint8 *InternalSerializeWithCachedSizesToArray(
                ::PROTOBUF_NAMESPACE_ID::uint8 *target) const final;
            int GetCachedSize() const final { return _cached_size_.Get(); }

        private:
            inline void SharedCtor();
            inline void SharedDtor();
            void SetCachedSize(int size) const final;
            void InternalSwap(ClusterId *other);
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                return "cluster.rpc.ClusterId";
            }

        private:
            inline ::PROTOBUF_NAMESPACE_ID::Arena *GetArenaNoVirtual() const { return nullptr; }
            inline void *MaybeArenaPtr() const { return nullptr; }

        public:
            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        private:
            static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
                ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
                    &::descriptor_table_rpc_2fleader_2eproto);
                return ::descriptor_table_rpc_2fleader_2eproto
                    .file_level_metadata[kIndexInFileMessages];
            }

        public:
            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // string host = 1;
            void clear_host();
            static const int kHostFieldNumber = 1;
            const std::string &host() const;
            void set_host(const std::string &value);
            void set_host(std::string &&value);
            void set_host(const char *value);
            void set_host(const char *value, size_t size);
            std::string *mutable_host();
            std::string *release_host();
            void set_allocated_host(std::string *host);

            // fixed32 port = 2;
            void clear_port();
            static const int kPortFieldNumber = 2;
            ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
            void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);

            // @@protoc_insertion_point(class_scope:cluster.rpc.ClusterId)
        private:
            class HasBitSetters;

            ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
            ::PROTOBUF_NAMESPACE_ID::uint32 port_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_rpc_2fleader_2eproto;
        };
        // -------------------------------------------------------------------

        class Request
            : public ::PROTOBUF_NAMESPACE_ID::
                  Message /* @@protoc_insertion_point(class_definition:cluster.rpc.Request) */ {
        public:
            Request();
            virtual ~Request();

            Request(const Request &from);
            Request(Request &&from) noexcept
                : Request() {
                *this = ::std::move(from);
            }

            inline Request &operator=(const Request &from) {
                CopyFrom(from);
                return *this;
            }
            inline Request &operator=(Request &&from) noexcept {
                if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                    if (this != &from)
                        InternalSwap(&from);
                } else {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                return GetDescriptor();
            }
            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                return GetMetadataStatic().descriptor;
            }
            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                return GetMetadataStatic().reflection;
            }
            static const Request &default_instance();

            static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
            static inline const Request *internal_default_instance() {
                return reinterpret_cast<const Request *>(&_Request_default_instance_);
            }
            static constexpr int kIndexInFileMessages = 2;

            void Swap(Request *other);
            friend void swap(Request &a, Request &b) { a.Swap(&b); }

            // implements Message ----------------------------------------------

            inline Request *New() const final { return CreateMaybeMessage<Request>(nullptr); }

            Request *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                return CreateMaybeMessage<Request>(arena);
            }
            void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void CopyFrom(const Request &from);
            void MergeFrom(const Request &from);
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            const char *_InternalParse(const char *ptr,
                                       ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
#else
            bool
            MergePartialFromCodedStream(::PROTOBUF_NAMESPACE_ID::io::CodedInputStream *input) final;
#endif // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            void SerializeWithCachedSizes(
                ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream *output) const final;
            ::PROTOBUF_NAMESPACE_ID::uint8 *InternalSerializeWithCachedSizesToArray(
                ::PROTOBUF_NAMESPACE_ID::uint8 *target) const final;
            int GetCachedSize() const final { return _cached_size_.Get(); }

        private:
            inline void SharedCtor();
            inline void SharedDtor();
            void SetCachedSize(int size) const final;
            void InternalSwap(Request *other);
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                return "cluster.rpc.Request";
            }

        private:
            inline ::PROTOBUF_NAMESPACE_ID::Arena *GetArenaNoVirtual() const { return nullptr; }
            inline void *MaybeArenaPtr() const { return nullptr; }

        public:
            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        private:
            static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
                ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
                    &::descriptor_table_rpc_2fleader_2eproto);
                return ::descriptor_table_rpc_2fleader_2eproto
                    .file_level_metadata[kIndexInFileMessages];
            }

        public:
            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // .cluster.rpc.Term term = 1;
            bool has_term() const;
            void clear_term();
            static const int kTermFieldNumber = 1;
            const ::cluster::rpc::Term &term() const;
            ::cluster::rpc::Term *release_term();
            ::cluster::rpc::Term *mutable_term();
            void set_allocated_term(::cluster::rpc::Term *term);

            // .cluster.rpc.ClusterId from = 2;
            bool has_from() const;
            void clear_from();
            static const int kFromFieldNumber = 2;
            const ::cluster::rpc::ClusterId &from() const;
            ::cluster::rpc::ClusterId *release_from();
            ::cluster::rpc::ClusterId *mutable_from();
            void set_allocated_from(::cluster::rpc::ClusterId *from);

            // @@protoc_insertion_point(class_scope:cluster.rpc.Request)
        private:
            class HasBitSetters;

            ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
            ::cluster::rpc::Term *term_;
            ::cluster::rpc::ClusterId *from_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_rpc_2fleader_2eproto;
        };
        // -------------------------------------------------------------------

        class Response
            : public ::PROTOBUF_NAMESPACE_ID::
                  Message /* @@protoc_insertion_point(class_definition:cluster.rpc.Response) */ {
        public:
            Response();
            virtual ~Response();

            Response(const Response &from);
            Response(Response &&from) noexcept
                : Response() {
                *this = ::std::move(from);
            }

            inline Response &operator=(const Response &from) {
                CopyFrom(from);
                return *this;
            }
            inline Response &operator=(Response &&from) noexcept {
                if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                    if (this != &from)
                        InternalSwap(&from);
                } else {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                return GetDescriptor();
            }
            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                return GetMetadataStatic().descriptor;
            }
            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                return GetMetadataStatic().reflection;
            }
            static const Response &default_instance();

            static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
            static inline const Response *internal_default_instance() {
                return reinterpret_cast<const Response *>(&_Response_default_instance_);
            }
            static constexpr int kIndexInFileMessages = 3;

            void Swap(Response *other);
            friend void swap(Response &a, Response &b) { a.Swap(&b); }

            // implements Message ----------------------------------------------

            inline Response *New() const final { return CreateMaybeMessage<Response>(nullptr); }

            Response *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                return CreateMaybeMessage<Response>(arena);
            }
            void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void CopyFrom(const Response &from);
            void MergeFrom(const Response &from);
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            const char *_InternalParse(const char *ptr,
                                       ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
#else
            bool
            MergePartialFromCodedStream(::PROTOBUF_NAMESPACE_ID::io::CodedInputStream *input) final;
#endif // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            void SerializeWithCachedSizes(
                ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream *output) const final;
            ::PROTOBUF_NAMESPACE_ID::uint8 *InternalSerializeWithCachedSizesToArray(
                ::PROTOBUF_NAMESPACE_ID::uint8 *target) const final;
            int GetCachedSize() const final { return _cached_size_.Get(); }

        private:
            inline void SharedCtor();
            inline void SharedDtor();
            void SetCachedSize(int size) const final;
            void InternalSwap(Response *other);
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                return "cluster.rpc.Response";
            }

        private:
            inline ::PROTOBUF_NAMESPACE_ID::Arena *GetArenaNoVirtual() const { return nullptr; }
            inline void *MaybeArenaPtr() const { return nullptr; }

        public:
            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        private:
            static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
                ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
                    &::descriptor_table_rpc_2fleader_2eproto);
                return ::descriptor_table_rpc_2fleader_2eproto
                    .file_level_metadata[kIndexInFileMessages];
            }

        public:
            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // .cluster.rpc.Term term = 1;
            bool has_term() const;
            void clear_term();
            static const int kTermFieldNumber = 1;
            const ::cluster::rpc::Term &term() const;
            ::cluster::rpc::Term *release_term();
            ::cluster::rpc::Term *mutable_term();
            void set_allocated_term(::cluster::rpc::Term *term);

            // .cluster.rpc.ClusterId from = 2;
            bool has_from() const;
            void clear_from();
            static const int kFromFieldNumber = 2;
            const ::cluster::rpc::ClusterId &from() const;
            ::cluster::rpc::ClusterId *release_from();
            ::cluster::rpc::ClusterId *mutable_from();
            void set_allocated_from(::cluster::rpc::ClusterId *from);

            // @@protoc_insertion_point(class_scope:cluster.rpc.Response)
        private:
            class HasBitSetters;

            ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
            ::cluster::rpc::Term *term_;
            ::cluster::rpc::ClusterId *from_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_rpc_2fleader_2eproto;
        };
        // -------------------------------------------------------------------

        class Heartbeat
            : public ::PROTOBUF_NAMESPACE_ID::
                  Message /* @@protoc_insertion_point(class_definition:cluster.rpc.Heartbeat) */ {
        public:
            Heartbeat();
            virtual ~Heartbeat();

            Heartbeat(const Heartbeat &from);
            Heartbeat(Heartbeat &&from) noexcept
                : Heartbeat() {
                *this = ::std::move(from);
            }

            inline Heartbeat &operator=(const Heartbeat &from) {
                CopyFrom(from);
                return *this;
            }
            inline Heartbeat &operator=(Heartbeat &&from) noexcept {
                if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                    if (this != &from)
                        InternalSwap(&from);
                } else {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                return GetDescriptor();
            }
            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                return GetMetadataStatic().descriptor;
            }
            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                return GetMetadataStatic().reflection;
            }
            static const Heartbeat &default_instance();

            static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
            static inline const Heartbeat *internal_default_instance() {
                return reinterpret_cast<const Heartbeat *>(&_Heartbeat_default_instance_);
            }
            static constexpr int kIndexInFileMessages = 4;

            void Swap(Heartbeat *other);
            friend void swap(Heartbeat &a, Heartbeat &b) { a.Swap(&b); }

            // implements Message ----------------------------------------------

            inline Heartbeat *New() const final { return CreateMaybeMessage<Heartbeat>(nullptr); }

            Heartbeat *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                return CreateMaybeMessage<Heartbeat>(arena);
            }
            void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void CopyFrom(const Heartbeat &from);
            void MergeFrom(const Heartbeat &from);
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            const char *_InternalParse(const char *ptr,
                                       ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
#else
            bool
            MergePartialFromCodedStream(::PROTOBUF_NAMESPACE_ID::io::CodedInputStream *input) final;
#endif // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            void SerializeWithCachedSizes(
                ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream *output) const final;
            ::PROTOBUF_NAMESPACE_ID::uint8 *InternalSerializeWithCachedSizesToArray(
                ::PROTOBUF_NAMESPACE_ID::uint8 *target) const final;
            int GetCachedSize() const final { return _cached_size_.Get(); }

        private:
            inline void SharedCtor();
            inline void SharedDtor();
            void SetCachedSize(int size) const final;
            void InternalSwap(Heartbeat *other);
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                return "cluster.rpc.Heartbeat";
            }

        private:
            inline ::PROTOBUF_NAMESPACE_ID::Arena *GetArenaNoVirtual() const { return nullptr; }
            inline void *MaybeArenaPtr() const { return nullptr; }

        public:
            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        private:
            static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
                ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
                    &::descriptor_table_rpc_2fleader_2eproto);
                return ::descriptor_table_rpc_2fleader_2eproto
                    .file_level_metadata[kIndexInFileMessages];
            }

        public:
            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // .cluster.rpc.Term term = 1;
            bool has_term() const;
            void clear_term();
            static const int kTermFieldNumber = 1;
            const ::cluster::rpc::Term &term() const;
            ::cluster::rpc::Term *release_term();
            ::cluster::rpc::Term *mutable_term();
            void set_allocated_term(::cluster::rpc::Term *term);

            // .cluster.rpc.ClusterId from = 2;
            bool has_from() const;
            void clear_from();
            static const int kFromFieldNumber = 2;
            const ::cluster::rpc::ClusterId &from() const;
            ::cluster::rpc::ClusterId *release_from();
            ::cluster::rpc::ClusterId *mutable_from();
            void set_allocated_from(::cluster::rpc::ClusterId *from);

            // @@protoc_insertion_point(class_scope:cluster.rpc.Heartbeat)
        private:
            class HasBitSetters;

            ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
            ::cluster::rpc::Term *term_;
            ::cluster::rpc::ClusterId *from_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_rpc_2fleader_2eproto;
        };
        // -------------------------------------------------------------------

        class NetworkStateRequest
            : public ::PROTOBUF_NAMESPACE_ID::
                  Message /* @@protoc_insertion_point(class_definition:cluster.rpc.NetworkStateRequest)
                           */
        {
        public:
            NetworkStateRequest();
            virtual ~NetworkStateRequest();

            NetworkStateRequest(const NetworkStateRequest &from);
            NetworkStateRequest(NetworkStateRequest &&from) noexcept
                : NetworkStateRequest() {
                *this = ::std::move(from);
            }

            inline NetworkStateRequest &operator=(const NetworkStateRequest &from) {
                CopyFrom(from);
                return *this;
            }
            inline NetworkStateRequest &operator=(NetworkStateRequest &&from) noexcept {
                if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                    if (this != &from)
                        InternalSwap(&from);
                } else {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                return GetDescriptor();
            }
            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                return GetMetadataStatic().descriptor;
            }
            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                return GetMetadataStatic().reflection;
            }
            static const NetworkStateRequest &default_instance();

            static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
            static inline const NetworkStateRequest *internal_default_instance() {
                return reinterpret_cast<const NetworkStateRequest *>(
                    &_NetworkStateRequest_default_instance_);
            }
            static constexpr int kIndexInFileMessages = 5;

            void Swap(NetworkStateRequest *other);
            friend void swap(NetworkStateRequest &a, NetworkStateRequest &b) { a.Swap(&b); }

            // implements Message ----------------------------------------------

            inline NetworkStateRequest *New() const final {
                return CreateMaybeMessage<NetworkStateRequest>(nullptr);
            }

            NetworkStateRequest *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                return CreateMaybeMessage<NetworkStateRequest>(arena);
            }
            void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void CopyFrom(const NetworkStateRequest &from);
            void MergeFrom(const NetworkStateRequest &from);
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            const char *_InternalParse(const char *ptr,
                                       ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
#else
            bool
            MergePartialFromCodedStream(::PROTOBUF_NAMESPACE_ID::io::CodedInputStream *input) final;
#endif // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            void SerializeWithCachedSizes(
                ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream *output) const final;
            ::PROTOBUF_NAMESPACE_ID::uint8 *InternalSerializeWithCachedSizesToArray(
                ::PROTOBUF_NAMESPACE_ID::uint8 *target) const final;
            int GetCachedSize() const final { return _cached_size_.Get(); }

        private:
            inline void SharedCtor();
            inline void SharedDtor();
            void SetCachedSize(int size) const final;
            void InternalSwap(NetworkStateRequest *other);
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                return "cluster.rpc.NetworkStateRequest";
            }

        private:
            inline ::PROTOBUF_NAMESPACE_ID::Arena *GetArenaNoVirtual() const { return nullptr; }
            inline void *MaybeArenaPtr() const { return nullptr; }

        public:
            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        private:
            static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
                ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
                    &::descriptor_table_rpc_2fleader_2eproto);
                return ::descriptor_table_rpc_2fleader_2eproto
                    .file_level_metadata[kIndexInFileMessages];
            }

        public:
            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // .cluster.rpc.ClusterId from = 1;
            bool has_from() const;
            void clear_from();
            static const int kFromFieldNumber = 1;
            const ::cluster::rpc::ClusterId &from() const;
            ::cluster::rpc::ClusterId *release_from();
            ::cluster::rpc::ClusterId *mutable_from();
            void set_allocated_from(::cluster::rpc::ClusterId *from);

            // @@protoc_insertion_point(class_scope:cluster.rpc.NetworkStateRequest)
        private:
            class HasBitSetters;

            ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
            ::cluster::rpc::ClusterId *from_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_rpc_2fleader_2eproto;
        };
        // -------------------------------------------------------------------

        class NetworkStateResponse
            : public ::PROTOBUF_NAMESPACE_ID::
                  Message /* @@protoc_insertion_point(class_definition:cluster.rpc.NetworkStateResponse)
                           */
        {
        public:
            NetworkStateResponse();
            virtual ~NetworkStateResponse();

            NetworkStateResponse(const NetworkStateResponse &from);
            NetworkStateResponse(NetworkStateResponse &&from) noexcept
                : NetworkStateResponse() {
                *this = ::std::move(from);
            }

            inline NetworkStateResponse &operator=(const NetworkStateResponse &from) {
                CopyFrom(from);
                return *this;
            }
            inline NetworkStateResponse &operator=(NetworkStateResponse &&from) noexcept {
                if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                    if (this != &from)
                        InternalSwap(&from);
                } else {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                return GetDescriptor();
            }
            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                return GetMetadataStatic().descriptor;
            }
            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                return GetMetadataStatic().reflection;
            }
            static const NetworkStateResponse &default_instance();

            static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
            static inline const NetworkStateResponse *internal_default_instance() {
                return reinterpret_cast<const NetworkStateResponse *>(
                    &_NetworkStateResponse_default_instance_);
            }
            static constexpr int kIndexInFileMessages = 6;

            void Swap(NetworkStateResponse *other);
            friend void swap(NetworkStateResponse &a, NetworkStateResponse &b) { a.Swap(&b); }

            // implements Message ----------------------------------------------

            inline NetworkStateResponse *New() const final {
                return CreateMaybeMessage<NetworkStateResponse>(nullptr);
            }

            NetworkStateResponse *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                return CreateMaybeMessage<NetworkStateResponse>(arena);
            }
            void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;
            void CopyFrom(const NetworkStateResponse &from);
            void MergeFrom(const NetworkStateResponse &from);
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            const char *_InternalParse(const char *ptr,
                                       ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
#else
            bool
            MergePartialFromCodedStream(::PROTOBUF_NAMESPACE_ID::io::CodedInputStream *input) final;
#endif // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
            void SerializeWithCachedSizes(
                ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream *output) const final;
            ::PROTOBUF_NAMESPACE_ID::uint8 *InternalSerializeWithCachedSizesToArray(
                ::PROTOBUF_NAMESPACE_ID::uint8 *target) const final;
            int GetCachedSize() const final { return _cached_size_.Get(); }

        private:
            inline void SharedCtor();
            inline void SharedDtor();
            void SetCachedSize(int size) const final;
            void InternalSwap(NetworkStateResponse *other);
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                return "cluster.rpc.NetworkStateResponse";
            }

        private:
            inline ::PROTOBUF_NAMESPACE_ID::Arena *GetArenaNoVirtual() const { return nullptr; }
            inline void *MaybeArenaPtr() const { return nullptr; }

        public:
            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        private:
            static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
                ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
                    &::descriptor_table_rpc_2fleader_2eproto);
                return ::descriptor_table_rpc_2fleader_2eproto
                    .file_level_metadata[kIndexInFileMessages];
            }

        public:
            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // repeated .cluster.rpc.ClusterId clusters = 3;
            int clusters_size() const;
            void clear_clusters();
            static const int kClustersFieldNumber = 3;
            ::cluster::rpc::ClusterId *mutable_clusters(int index);
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cluster::rpc::ClusterId> *
            mutable_clusters();
            const ::cluster::rpc::ClusterId &clusters(int index) const;
            ::cluster::rpc::ClusterId *add_clusters();
            const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cluster::rpc::ClusterId> &
            clusters() const;

            // .cluster.rpc.Term term = 1;
            bool has_term() const;
            void clear_term();
            static const int kTermFieldNumber = 1;
            const ::cluster::rpc::Term &term() const;
            ::cluster::rpc::Term *release_term();
            ::cluster::rpc::Term *mutable_term();
            void set_allocated_term(::cluster::rpc::Term *term);

            // .cluster.rpc.ClusterId from = 2;
            bool has_from() const;
            void clear_from();
            static const int kFromFieldNumber = 2;
            const ::cluster::rpc::ClusterId &from() const;
            ::cluster::rpc::ClusterId *release_from();
            ::cluster::rpc::ClusterId *mutable_from();
            void set_allocated_from(::cluster::rpc::ClusterId *from);

            // .cluster.rpc.ClusterId leader = 4;
            bool has_leader() const;
            void clear_leader();
            static const int kLeaderFieldNumber = 4;
            const ::cluster::rpc::ClusterId &leader() const;
            ::cluster::rpc::ClusterId *release_leader();
            ::cluster::rpc::ClusterId *mutable_leader();
            void set_allocated_leader(::cluster::rpc::ClusterId *leader);

            // @@protoc_insertion_point(class_scope:cluster.rpc.NetworkStateResponse)
        private:
            class HasBitSetters;

            ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cluster::rpc::ClusterId> clusters_;
            ::cluster::rpc::Term *term_;
            ::cluster::rpc::ClusterId *from_;
            ::cluster::rpc::ClusterId *leader_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_rpc_2fleader_2eproto;
        };
        // ===================================================================

        // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
       // Term

        // repeated uint64 counter = 1;
        inline int Term::counter_size() const { return counter_.size(); }
        inline void Term::clear_counter() { counter_.Clear(); }
        inline ::PROTOBUF_NAMESPACE_ID::uint64 Term::counter(int index) const {
            // @@protoc_insertion_point(field_get:cluster.rpc.Term.counter)
            return counter_.Get(index);
        }
        inline void Term::set_counter(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
            counter_.Set(index, value);
            // @@protoc_insertion_point(field_set:cluster.rpc.Term.counter)
        }
        inline void Term::add_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
            counter_.Add(value);
            // @@protoc_insertion_point(field_add:cluster.rpc.Term.counter)
        }
        inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::PROTOBUF_NAMESPACE_ID::uint64> &
        Term::counter() const {
            // @@protoc_insertion_point(field_list:cluster.rpc.Term.counter)
            return counter_;
        }
        inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::PROTOBUF_NAMESPACE_ID::uint64> *
        Term::mutable_counter() {
            // @@protoc_insertion_point(field_mutable_list:cluster.rpc.Term.counter)
            return &counter_;
        }

        // -------------------------------------------------------------------

        // ClusterId

        // string host = 1;
        inline void ClusterId::clear_host() {
            host_.ClearToEmptyNoArena(
                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        }
        inline const std::string &ClusterId::host() const {
            // @@protoc_insertion_point(field_get:cluster.rpc.ClusterId.host)
            return host_.GetNoArena();
        }
        inline void ClusterId::set_host(const std::string &value) {

            host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                             value);
            // @@protoc_insertion_point(field_set:cluster.rpc.ClusterId.host)
        }
        inline void ClusterId::set_host(std::string &&value) {

            host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                             ::std::move(value));
            // @@protoc_insertion_point(field_set_rvalue:cluster.rpc.ClusterId.host)
        }
        inline void ClusterId::set_host(const char *value) {
            GOOGLE_DCHECK(value != nullptr);

            host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                             ::std::string(value));
            // @@protoc_insertion_point(field_set_char:cluster.rpc.ClusterId.host)
        }
        inline void ClusterId::set_host(const char *value, size_t size) {

            host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                             ::std::string(reinterpret_cast<const char *>(value), size));
            // @@protoc_insertion_point(field_set_pointer:cluster.rpc.ClusterId.host)
        }
        inline std::string *ClusterId::mutable_host() {

            // @@protoc_insertion_point(field_mutable:cluster.rpc.ClusterId.host)
            return host_.MutableNoArena(
                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        }
        inline std::string *ClusterId::release_host() {
            // @@protoc_insertion_point(field_release:cluster.rpc.ClusterId.host)

            return host_.ReleaseNoArena(
                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        }
        inline void ClusterId::set_allocated_host(std::string *host) {
            if (host != nullptr) {

            } else {
            }
            host_.SetAllocatedNoArena(
                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host);
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.ClusterId.host)
        }

        // fixed32 port = 2;
        inline void ClusterId::clear_port() { port_ = 0u; }
        inline ::PROTOBUF_NAMESPACE_ID::uint32 ClusterId::port() const {
            // @@protoc_insertion_point(field_get:cluster.rpc.ClusterId.port)
            return port_;
        }
        inline void ClusterId::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {

            port_ = value;
            // @@protoc_insertion_point(field_set:cluster.rpc.ClusterId.port)
        }

        // -------------------------------------------------------------------

        // Request

        // .cluster.rpc.Term term = 1;
        inline bool Request::has_term() const {
            return this != internal_default_instance() && term_ != nullptr;
        }
        inline void Request::clear_term() {
            if (GetArenaNoVirtual() == nullptr && term_ != nullptr) {
                delete term_;
            }
            term_ = nullptr;
        }
        inline const ::cluster::rpc::Term &Request::term() const {
            const ::cluster::rpc::Term *p = term_;
            // @@protoc_insertion_point(field_get:cluster.rpc.Request.term)
            return p != nullptr ? *p
                                : *reinterpret_cast<const ::cluster::rpc::Term *>(
                                      &::cluster::rpc::_Term_default_instance_);
        }
        inline ::cluster::rpc::Term *Request::release_term() {
            // @@protoc_insertion_point(field_release:cluster.rpc.Request.term)

            ::cluster::rpc::Term *temp = term_;
            term_ = nullptr;
            return temp;
        }
        inline ::cluster::rpc::Term *Request::mutable_term() {

            if (term_ == nullptr) {
                auto *p = CreateMaybeMessage<::cluster::rpc::Term>(GetArenaNoVirtual());
                term_ = p;
            }
            // @@protoc_insertion_point(field_mutable:cluster.rpc.Request.term)
            return term_;
        }
        inline void Request::set_allocated_term(::cluster::rpc::Term *term) {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaNoVirtual();
            if (message_arena == nullptr) {
                delete term_;
            }
            if (term) {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena = nullptr;
                if (message_arena != submessage_arena) {
                    term = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, term,
                                                                              submessage_arena);
                }

            } else {
            }
            term_ = term;
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.Request.term)
        }

        // .cluster.rpc.ClusterId from = 2;
        inline bool Request::has_from() const {
            return this != internal_default_instance() && from_ != nullptr;
        }
        inline void Request::clear_from() {
            if (GetArenaNoVirtual() == nullptr && from_ != nullptr) {
                delete from_;
            }
            from_ = nullptr;
        }
        inline const ::cluster::rpc::ClusterId &Request::from() const {
            const ::cluster::rpc::ClusterId *p = from_;
            // @@protoc_insertion_point(field_get:cluster.rpc.Request.from)
            return p != nullptr ? *p
                                : *reinterpret_cast<const ::cluster::rpc::ClusterId *>(
                                      &::cluster::rpc::_ClusterId_default_instance_);
        }
        inline ::cluster::rpc::ClusterId *Request::release_from() {
            // @@protoc_insertion_point(field_release:cluster.rpc.Request.from)

            ::cluster::rpc::ClusterId *temp = from_;
            from_ = nullptr;
            return temp;
        }
        inline ::cluster::rpc::ClusterId *Request::mutable_from() {

            if (from_ == nullptr) {
                auto *p = CreateMaybeMessage<::cluster::rpc::ClusterId>(GetArenaNoVirtual());
                from_ = p;
            }
            // @@protoc_insertion_point(field_mutable:cluster.rpc.Request.from)
            return from_;
        }
        inline void Request::set_allocated_from(::cluster::rpc::ClusterId *from) {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaNoVirtual();
            if (message_arena == nullptr) {
                delete from_;
            }
            if (from) {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena = nullptr;
                if (message_arena != submessage_arena) {
                    from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, from,
                                                                              submessage_arena);
                }

            } else {
            }
            from_ = from;
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.Request.from)
        }

        // -------------------------------------------------------------------

        // Response

        // .cluster.rpc.Term term = 1;
        inline bool Response::has_term() const {
            return this != internal_default_instance() && term_ != nullptr;
        }
        inline void Response::clear_term() {
            if (GetArenaNoVirtual() == nullptr && term_ != nullptr) {
                delete term_;
            }
            term_ = nullptr;
        }
        inline const ::cluster::rpc::Term &Response::term() const {
            const ::cluster::rpc::Term *p = term_;
            // @@protoc_insertion_point(field_get:cluster.rpc.Response.term)
            return p != nullptr ? *p
                                : *reinterpret_cast<const ::cluster::rpc::Term *>(
                                      &::cluster::rpc::_Term_default_instance_);
        }
        inline ::cluster::rpc::Term *Response::release_term() {
            // @@protoc_insertion_point(field_release:cluster.rpc.Response.term)

            ::cluster::rpc::Term *temp = term_;
            term_ = nullptr;
            return temp;
        }
        inline ::cluster::rpc::Term *Response::mutable_term() {

            if (term_ == nullptr) {
                auto *p = CreateMaybeMessage<::cluster::rpc::Term>(GetArenaNoVirtual());
                term_ = p;
            }
            // @@protoc_insertion_point(field_mutable:cluster.rpc.Response.term)
            return term_;
        }
        inline void Response::set_allocated_term(::cluster::rpc::Term *term) {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaNoVirtual();
            if (message_arena == nullptr) {
                delete term_;
            }
            if (term) {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena = nullptr;
                if (message_arena != submessage_arena) {
                    term = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, term,
                                                                              submessage_arena);
                }

            } else {
            }
            term_ = term;
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.Response.term)
        }

        // .cluster.rpc.ClusterId from = 2;
        inline bool Response::has_from() const {
            return this != internal_default_instance() && from_ != nullptr;
        }
        inline void Response::clear_from() {
            if (GetArenaNoVirtual() == nullptr && from_ != nullptr) {
                delete from_;
            }
            from_ = nullptr;
        }
        inline const ::cluster::rpc::ClusterId &Response::from() const {
            const ::cluster::rpc::ClusterId *p = from_;
            // @@protoc_insertion_point(field_get:cluster.rpc.Response.from)
            return p != nullptr ? *p
                                : *reinterpret_cast<const ::cluster::rpc::ClusterId *>(
                                      &::cluster::rpc::_ClusterId_default_instance_);
        }
        inline ::cluster::rpc::ClusterId *Response::release_from() {
            // @@protoc_insertion_point(field_release:cluster.rpc.Response.from)

            ::cluster::rpc::ClusterId *temp = from_;
            from_ = nullptr;
            return temp;
        }
        inline ::cluster::rpc::ClusterId *Response::mutable_from() {

            if (from_ == nullptr) {
                auto *p = CreateMaybeMessage<::cluster::rpc::ClusterId>(GetArenaNoVirtual());
                from_ = p;
            }
            // @@protoc_insertion_point(field_mutable:cluster.rpc.Response.from)
            return from_;
        }
        inline void Response::set_allocated_from(::cluster::rpc::ClusterId *from) {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaNoVirtual();
            if (message_arena == nullptr) {
                delete from_;
            }
            if (from) {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena = nullptr;
                if (message_arena != submessage_arena) {
                    from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, from,
                                                                              submessage_arena);
                }

            } else {
            }
            from_ = from;
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.Response.from)
        }

        // -------------------------------------------------------------------

        // Heartbeat

        // .cluster.rpc.Term term = 1;
        inline bool Heartbeat::has_term() const {
            return this != internal_default_instance() && term_ != nullptr;
        }
        inline void Heartbeat::clear_term() {
            if (GetArenaNoVirtual() == nullptr && term_ != nullptr) {
                delete term_;
            }
            term_ = nullptr;
        }
        inline const ::cluster::rpc::Term &Heartbeat::term() const {
            const ::cluster::rpc::Term *p = term_;
            // @@protoc_insertion_point(field_get:cluster.rpc.Heartbeat.term)
            return p != nullptr ? *p
                                : *reinterpret_cast<const ::cluster::rpc::Term *>(
                                      &::cluster::rpc::_Term_default_instance_);
        }
        inline ::cluster::rpc::Term *Heartbeat::release_term() {
            // @@protoc_insertion_point(field_release:cluster.rpc.Heartbeat.term)

            ::cluster::rpc::Term *temp = term_;
            term_ = nullptr;
            return temp;
        }
        inline ::cluster::rpc::Term *Heartbeat::mutable_term() {

            if (term_ == nullptr) {
                auto *p = CreateMaybeMessage<::cluster::rpc::Term>(GetArenaNoVirtual());
                term_ = p;
            }
            // @@protoc_insertion_point(field_mutable:cluster.rpc.Heartbeat.term)
            return term_;
        }
        inline void Heartbeat::set_allocated_term(::cluster::rpc::Term *term) {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaNoVirtual();
            if (message_arena == nullptr) {
                delete term_;
            }
            if (term) {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena = nullptr;
                if (message_arena != submessage_arena) {
                    term = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, term,
                                                                              submessage_arena);
                }

            } else {
            }
            term_ = term;
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.Heartbeat.term)
        }

        // .cluster.rpc.ClusterId from = 2;
        inline bool Heartbeat::has_from() const {
            return this != internal_default_instance() && from_ != nullptr;
        }
        inline void Heartbeat::clear_from() {
            if (GetArenaNoVirtual() == nullptr && from_ != nullptr) {
                delete from_;
            }
            from_ = nullptr;
        }
        inline const ::cluster::rpc::ClusterId &Heartbeat::from() const {
            const ::cluster::rpc::ClusterId *p = from_;
            // @@protoc_insertion_point(field_get:cluster.rpc.Heartbeat.from)
            return p != nullptr ? *p
                                : *reinterpret_cast<const ::cluster::rpc::ClusterId *>(
                                      &::cluster::rpc::_ClusterId_default_instance_);
        }
        inline ::cluster::rpc::ClusterId *Heartbeat::release_from() {
            // @@protoc_insertion_point(field_release:cluster.rpc.Heartbeat.from)

            ::cluster::rpc::ClusterId *temp = from_;
            from_ = nullptr;
            return temp;
        }
        inline ::cluster::rpc::ClusterId *Heartbeat::mutable_from() {

            if (from_ == nullptr) {
                auto *p = CreateMaybeMessage<::cluster::rpc::ClusterId>(GetArenaNoVirtual());
                from_ = p;
            }
            // @@protoc_insertion_point(field_mutable:cluster.rpc.Heartbeat.from)
            return from_;
        }
        inline void Heartbeat::set_allocated_from(::cluster::rpc::ClusterId *from) {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaNoVirtual();
            if (message_arena == nullptr) {
                delete from_;
            }
            if (from) {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena = nullptr;
                if (message_arena != submessage_arena) {
                    from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, from,
                                                                              submessage_arena);
                }

            } else {
            }
            from_ = from;
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.Heartbeat.from)
        }

        // -------------------------------------------------------------------

        // NetworkStateRequest

        // .cluster.rpc.ClusterId from = 1;
        inline bool NetworkStateRequest::has_from() const {
            return this != internal_default_instance() && from_ != nullptr;
        }
        inline void NetworkStateRequest::clear_from() {
            if (GetArenaNoVirtual() == nullptr && from_ != nullptr) {
                delete from_;
            }
            from_ = nullptr;
        }
        inline const ::cluster::rpc::ClusterId &NetworkStateRequest::from() const {
            const ::cluster::rpc::ClusterId *p = from_;
            // @@protoc_insertion_point(field_get:cluster.rpc.NetworkStateRequest.from)
            return p != nullptr ? *p
                                : *reinterpret_cast<const ::cluster::rpc::ClusterId *>(
                                      &::cluster::rpc::_ClusterId_default_instance_);
        }
        inline ::cluster::rpc::ClusterId *NetworkStateRequest::release_from() {
            // @@protoc_insertion_point(field_release:cluster.rpc.NetworkStateRequest.from)

            ::cluster::rpc::ClusterId *temp = from_;
            from_ = nullptr;
            return temp;
        }
        inline ::cluster::rpc::ClusterId *NetworkStateRequest::mutable_from() {

            if (from_ == nullptr) {
                auto *p = CreateMaybeMessage<::cluster::rpc::ClusterId>(GetArenaNoVirtual());
                from_ = p;
            }
            // @@protoc_insertion_point(field_mutable:cluster.rpc.NetworkStateRequest.from)
            return from_;
        }
        inline void NetworkStateRequest::set_allocated_from(::cluster::rpc::ClusterId *from) {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaNoVirtual();
            if (message_arena == nullptr) {
                delete from_;
            }
            if (from) {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena = nullptr;
                if (message_arena != submessage_arena) {
                    from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, from,
                                                                              submessage_arena);
                }

            } else {
            }
            from_ = from;
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.NetworkStateRequest.from)
        }

        // -------------------------------------------------------------------

        // NetworkStateResponse

        // .cluster.rpc.Term term = 1;
        inline bool NetworkStateResponse::has_term() const {
            return this != internal_default_instance() && term_ != nullptr;
        }
        inline void NetworkStateResponse::clear_term() {
            if (GetArenaNoVirtual() == nullptr && term_ != nullptr) {
                delete term_;
            }
            term_ = nullptr;
        }
        inline const ::cluster::rpc::Term &NetworkStateResponse::term() const {
            const ::cluster::rpc::Term *p = term_;
            // @@protoc_insertion_point(field_get:cluster.rpc.NetworkStateResponse.term)
            return p != nullptr ? *p
                                : *reinterpret_cast<const ::cluster::rpc::Term *>(
                                      &::cluster::rpc::_Term_default_instance_);
        }
        inline ::cluster::rpc::Term *NetworkStateResponse::release_term() {
            // @@protoc_insertion_point(field_release:cluster.rpc.NetworkStateResponse.term)

            ::cluster::rpc::Term *temp = term_;
            term_ = nullptr;
            return temp;
        }
        inline ::cluster::rpc::Term *NetworkStateResponse::mutable_term() {

            if (term_ == nullptr) {
                auto *p = CreateMaybeMessage<::cluster::rpc::Term>(GetArenaNoVirtual());
                term_ = p;
            }
            // @@protoc_insertion_point(field_mutable:cluster.rpc.NetworkStateResponse.term)
            return term_;
        }
        inline void NetworkStateResponse::set_allocated_term(::cluster::rpc::Term *term) {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaNoVirtual();
            if (message_arena == nullptr) {
                delete term_;
            }
            if (term) {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena = nullptr;
                if (message_arena != submessage_arena) {
                    term = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, term,
                                                                              submessage_arena);
                }

            } else {
            }
            term_ = term;
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.NetworkStateResponse.term)
        }

        // .cluster.rpc.ClusterId from = 2;
        inline bool NetworkStateResponse::has_from() const {
            return this != internal_default_instance() && from_ != nullptr;
        }
        inline void NetworkStateResponse::clear_from() {
            if (GetArenaNoVirtual() == nullptr && from_ != nullptr) {
                delete from_;
            }
            from_ = nullptr;
        }
        inline const ::cluster::rpc::ClusterId &NetworkStateResponse::from() const {
            const ::cluster::rpc::ClusterId *p = from_;
            // @@protoc_insertion_point(field_get:cluster.rpc.NetworkStateResponse.from)
            return p != nullptr ? *p
                                : *reinterpret_cast<const ::cluster::rpc::ClusterId *>(
                                      &::cluster::rpc::_ClusterId_default_instance_);
        }
        inline ::cluster::rpc::ClusterId *NetworkStateResponse::release_from() {
            // @@protoc_insertion_point(field_release:cluster.rpc.NetworkStateResponse.from)

            ::cluster::rpc::ClusterId *temp = from_;
            from_ = nullptr;
            return temp;
        }
        inline ::cluster::rpc::ClusterId *NetworkStateResponse::mutable_from() {

            if (from_ == nullptr) {
                auto *p = CreateMaybeMessage<::cluster::rpc::ClusterId>(GetArenaNoVirtual());
                from_ = p;
            }
            // @@protoc_insertion_point(field_mutable:cluster.rpc.NetworkStateResponse.from)
            return from_;
        }
        inline void NetworkStateResponse::set_allocated_from(::cluster::rpc::ClusterId *from) {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaNoVirtual();
            if (message_arena == nullptr) {
                delete from_;
            }
            if (from) {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena = nullptr;
                if (message_arena != submessage_arena) {
                    from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, from,
                                                                              submessage_arena);
                }

            } else {
            }
            from_ = from;
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.NetworkStateResponse.from)
        }

        // repeated .cluster.rpc.ClusterId clusters = 3;
        inline int NetworkStateResponse::clusters_size() const { return clusters_.size(); }
        inline void NetworkStateResponse::clear_clusters() { clusters_.Clear(); }
        inline ::cluster::rpc::ClusterId *NetworkStateResponse::mutable_clusters(int index) {
            // @@protoc_insertion_point(field_mutable:cluster.rpc.NetworkStateResponse.clusters)
            return clusters_.Mutable(index);
        }
        inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cluster::rpc::ClusterId> *
        NetworkStateResponse::mutable_clusters() {
            // @@protoc_insertion_point(field_mutable_list:cluster.rpc.NetworkStateResponse.clusters)
            return &clusters_;
        }
        inline const ::cluster::rpc::ClusterId &NetworkStateResponse::clusters(int index) const {
            // @@protoc_insertion_point(field_get:cluster.rpc.NetworkStateResponse.clusters)
            return clusters_.Get(index);
        }
        inline ::cluster::rpc::ClusterId *NetworkStateResponse::add_clusters() {
            // @@protoc_insertion_point(field_add:cluster.rpc.NetworkStateResponse.clusters)
            return clusters_.Add();
        }
        inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cluster::rpc::ClusterId> &
        NetworkStateResponse::clusters() const {
            // @@protoc_insertion_point(field_list:cluster.rpc.NetworkStateResponse.clusters)
            return clusters_;
        }

        // .cluster.rpc.ClusterId leader = 4;
        inline bool NetworkStateResponse::has_leader() const {
            return this != internal_default_instance() && leader_ != nullptr;
        }
        inline void NetworkStateResponse::clear_leader() {
            if (GetArenaNoVirtual() == nullptr && leader_ != nullptr) {
                delete leader_;
            }
            leader_ = nullptr;
        }
        inline const ::cluster::rpc::ClusterId &NetworkStateResponse::leader() const {
            const ::cluster::rpc::ClusterId *p = leader_;
            // @@protoc_insertion_point(field_get:cluster.rpc.NetworkStateResponse.leader)
            return p != nullptr ? *p
                                : *reinterpret_cast<const ::cluster::rpc::ClusterId *>(
                                      &::cluster::rpc::_ClusterId_default_instance_);
        }
        inline ::cluster::rpc::ClusterId *NetworkStateResponse::release_leader() {
            // @@protoc_insertion_point(field_release:cluster.rpc.NetworkStateResponse.leader)

            ::cluster::rpc::ClusterId *temp = leader_;
            leader_ = nullptr;
            return temp;
        }
        inline ::cluster::rpc::ClusterId *NetworkStateResponse::mutable_leader() {

            if (leader_ == nullptr) {
                auto *p = CreateMaybeMessage<::cluster::rpc::ClusterId>(GetArenaNoVirtual());
                leader_ = p;
            }
            // @@protoc_insertion_point(field_mutable:cluster.rpc.NetworkStateResponse.leader)
            return leader_;
        }
        inline void NetworkStateResponse::set_allocated_leader(::cluster::rpc::ClusterId *leader) {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaNoVirtual();
            if (message_arena == nullptr) {
                delete leader_;
            }
            if (leader) {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena = nullptr;
                if (message_arena != submessage_arena) {
                    leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                        message_arena, leader, submessage_arena);
                }

            } else {
            }
            leader_ = leader;
            // @@protoc_insertion_point(field_set_allocated:cluster.rpc.NetworkStateResponse.leader)
        }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
       // -------------------------------------------------------------------

        // -------------------------------------------------------------------

        // -------------------------------------------------------------------

        // -------------------------------------------------------------------

        // -------------------------------------------------------------------

        // -------------------------------------------------------------------

        // @@protoc_insertion_point(namespace_scope)

    } // namespace rpc
} // namespace cluster

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rpc_2fleader_2eproto
